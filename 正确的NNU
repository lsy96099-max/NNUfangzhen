static std::vector<Pt> gen_N(float height, float width, int samples) {
    std::vector<Pt> out;

    int samples_vertical = samples;
    int samples_slant = samples * 1.6;   // 自动加密斜线（速度均匀）
    if (samples_slant < samples + 1) samples_slant = samples + 1;

    // ① 右竖线（上 → 下）
    for (int i = 0; i < samples_vertical; i++) {
        float t = (float)i / (samples_vertical - 1);
        out.emplace_back(height * (1 - t), +width * 0.5f, 0.0f);
    }

    // ② 中间斜线（左上 → 右下）
    for (int i = 0; i < samples_slant; i++) {
        float t = (float)i / (samples_slant - 1);
        float x = height * (1 - t);                  // height → 0
        float y = -width * 0.5f + t * width;         // -width/2 → +width/2
        out.emplace_back(x, y, 0.0f);
    }

    // ③ 左竖线（上 → 下）
    for (int i = 0; i < samples_vertical; i++) {
        float t = (float)i / (samples_vertical - 1);
        out.emplace_back(height * (1 - t), -width * 0.5f, 0.0f);
    }

    return out;
}


// 生成垂直 U 字（左下角为起点，x:上下，y:左右）
// 生成垂直 U 字（常规笔画：左上 -> 左下 -> 底部弧 -> 右上）
// x: 上下方向 (0=底, height=顶)， y: 左右方向 (左=-width/2, 右=+width/2)
static std::vector<Pt> gen_U(float height, float width, int samples_side, int samples_bottom) {
    std::vector<Pt> out;

    // ① 右竖线（下→上） ← 从原第3段搬到最前
  for (int i = 0; i < samples_side; i++) {
    float t = (float)i / (samples_side - 1);
    out.emplace_back(-height + t * height, width, 0.0f);
}

    // ② 底部半圆（左→右） ← 保持不变
    for (int i = 0; i < samples_bottom; i++) {
    float t = (float)(samples_bottom - 1 - i) / (samples_bottom - 1);
    float angle = M_PI * t;  // π → 0

    float cx = 0.0f;
    float cy = width * 0.5f;

    float rx = width * 0.5f;
    float ry = height * 0.2f;

    out.emplace_back(
        ry * sinf(angle),         // 弧形
        cy - rx * cosf(angle),    // 右 → 左
        0.0f
    );
}


    // ③ 左竖线（下→上） ← 从原第1段搬到最后
  for (int i = 0; i < samples_side; i++) {
    float t = -(float)i / (samples_side - 1);
    out.emplace_back(t * height, 0.0f, 0.0f);
}

    return out;
}
